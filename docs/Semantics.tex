\documentclass{article}
\usepackage[T1]{fontenc}

\usepackage{mathtools}
\usepackage{tabularx}

\newcommand{\lang}{a86}

\newcommand{\blankline}{\vspace{\baselineskip}}

\newcommand{\nonterm}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\term}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\class}[1]{\ensuremath{\text{\textit{#1}}}}


\title{\lang{} Interpreter Semantics}
\author{Pierce Darragh}

\begin{document}

\maketitle

This document describes the semantics used in the implementation of the \lang{}
interpreter.

\section{Syntax}

We provide a definition of the abstract syntax of the \lang{} language.

\blankline

\begin{tabular}{cclclclcl}
  \nonterm{r64}  & ::= & \term{rax}    & | & \term{rbx} & | & \term{rcx} & | & \term{rdx} \\
                 &  |  & \term{rbp}    & | & \term{rsp} & | & \term{rsi} & | & \term{rdi} \\
                 &  |  & \term{r8}     & | & \term{r9}  & | & \term{r10} & | & \term{r11} \\
                 &  |  & \term{r12}    & | & \term{r13} & | & \term{r14} & | & \term{r15} \\
  \\
  \nonterm{r}    & ::= & \nonterm{r64} & | & \term{eax} \\
  \\
  \nonterm{f}    & ::= & \term{CF}     & | & \term{ZF} & | & \term{SF} & | & \term{OF} \\
  \\
  \nonterm{l}    & ::= & \multicolumn{7}{l}{\class{labels}} \\
  \\
  \nonterm{z}    & ::= & \multicolumn{7}{l}{\class{integers}} \\
  \\
  \nonterm{bc}   & ::= & \multicolumn{7}{l}{\class{integers 0 through 63 inclusive}} \\
  \\
  \nonterm{off}  & ::= & \multicolumn{7}{l}{\term{Offset}\ \nonterm{r}\ \nonterm{z}} \\
  \\
  \nonterm{prog} & ::= & \multicolumn{7}{l}{\term{Program}\ (\nonterm{inst} \ldots)}
\end{tabular}

\blankline

\begin{tabular}{cclll}
  \nonterm{inst} & ::= & \term{Label} & \nonterm{loc} \\
                 &  |  & \term{Ret} \\
                 &  |  & \term{Call}  & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{Mov}   & (\nonterm{reg} | \nonterm{off}) & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Add}   & \nonterm{reg}                   & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Sub}   & \nonterm{reg}                   & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Cmp}   & (\nonterm{reg} | \nonterm{off}) & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Jmp}   & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{Je}    & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{Jne}   & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{Jl}    & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{Jg}    & (\nonterm{loc} | \nonterm{reg}) \\
                 &  |  & \term{And}   & (\nonterm{reg} | \nonterm{off}) & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Or}    & (\nonterm{reg} | \nonterm{off}) & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Xor}   & (\nonterm{reg} | \nonterm{off}) & (\nonterm{reg} | \nonterm{off} | \nonterm{int}) \\
                 &  |  & \term{Sal}   & \nonterm{reg}                   & \nonterm{bc} \\
                 &  |  & \term{Sar}   & \nonterm{reg}                   & \nonterm{bc} \\
                 &  |  & \term{Push}  & (\nonterm{int} | \nonterm{reg}) \\
                 &  |  & \term{Pop}   & \nonterm{reg} \\
                 &  |  & \term{Lea}   & (\nonterm{reg} | \nonterm{off}) & \nonterm{loc}
\end{tabular}

\section{Semantics (Informal)}

Before formalizing our semantics, we provide an informal specification. These
definitions are based on existing documentation and code. A formal semantics is
presented in the next section.

\subsection{Program}

First, we define a \emph{program}. A program is a list of instructions, where:

\begin{itemize}
\item The list is not empty.
\item The first instruction is a \term{Label}, which will be used as the entry
  point of the program (i.e., it is where execution begins).
\item Two \term{Label} instructions in the same program cannot use the same
  label name.
\end{itemize}

\subsection{Registers}

There are sixteen 64-bit registers, each corresponding to one of the names in
\nonterm{r64}. The special register reference \term{eax} refers to the lower 32
bits of the \term{rax} register.

\subsection{Flags}

There are four single-bit registers, called \emph{flags}, each corresponding to
one of the names in \nonterm{f}. The flags are used for arithmetic and
comparison operations:

{\renewcommand\labelitemii{}
  \begin{itemize}
  \item \term{OF} --- Overflow Flag

    Set when\ldots
    \begin{itemize}
    \item \ldots\emph{adding} two numbers with the same sign bit and the result
      has a different sign bit.
    \item \ldots\emph{subtracting} a negative number from a positive number and
      the result is negative.
    \item \ldots\emph{subtracting} a positive number from a negative number and
      the result is positive.
    \end{itemize}
  \item \term{SF} --- Sign Flag

    Set to the value of the sign bit of the result.
  \item \term{ZF} --- Zero Flag

    Set if the computed result is exactly \texttt{0}.
  \item \term{CF} --- Carry Flag

    Set if the (unsigned) arithmetic operation required an extra bit.
    % TODO: Do we even use CF? I think we might be able to leave it out.
  \end{itemize}

}

\noindent We say a flag ``is set'' if the value \texttt{1} is stored in it, or
the flag ``is clear'' or ``is unset'' if the value \texttt{0} is stored in it
instead. We may also use these terms as verbs, i.e., ``to set'' a flag means to
store \texttt{1} in it and so on. Note, however, that ``set'' is overloaded as a
verb, since it can also be used to indicate storing a specific value (e.g.,
``the flag is set to the value of <some computation>'').

\subsection{Memory}

All \lang{} programs also run with some limited amount of register-external
memory called the \emph{stack}. The stack starts at the highest available
address space and ``grows downwards'', which means that adding something to the
stack \emph{decrements} the pointer to the current position in the stack.

\subsection{Instructions}

There are 20 supported instructions in \lang{}, which work as follows:

{\renewcommand\labelitemii{}\renewcommand\labelitemiii{}
  \begin{itemize}
    % Label
  \item \texttt{Label l} creates a new label named \texttt{l} that points to the
    next instruction.
    % Ret
  \item \texttt{Ret} pops an address from the stack and jumps to it.
    % Call
  \item \texttt{Call dst} pushes the return address onto the stack, then jumps
    to the address indicated by the label or register in \texttt{dst}.
    % Mov
  \item \texttt{Mov dst src} moves the contents of/value at \texttt{src} into
    \texttt{dst}.

    NOTE: Either \texttt{dst} or \texttt{src} may be an offset, but not both.
    % Add
  \item \texttt{Add dst src} adds \texttt{src} to \texttt{dst} and writes the
    result to \texttt{dst}.

    Imagine we have only 4-bit numbers (instead of the 64 bits the \lang{}
    actually uses). Suppose we add \texttt{0111} and \texttt{1010}:

    \begin{center}
      \begin{tabular}{rl}
        \texttt{0111} \\
        \texttt{1010} & \texttt{+} \\
        \hline
        \texttt{10001}
      \end{tabular}
    \end{center}

    Due to carries, we have ended up with a 5-bit result, but we can only have 4
    bits to a number. The most-significant bit will be lost, but the \texttt{CF}
    flag will be set to indicate a carry has occurred.

    Here are some example additions of other 4-bit numbers:

    \begin{center}
      \begin{tabular}{ccccccc}
        \texttt{OF} & \texttt{SF} & \texttt{ZF} & \texttt{CF} & Left Operand  & Right Operand & Result \\
        \hline
        % Original example.
        \texttt{0}  & \texttt{0}  & \texttt{0}  & \texttt{1}  & \texttt{0111} & \texttt{1010} & \texttt{0001} \\
        % No flags (simple addition).
        \texttt{0}  & \texttt{0}  & \texttt{0}  & \texttt{0}  & \texttt{0010} & \texttt{0001} & \texttt{0011} \\
        % SF only. (Addition of positive to negative.)
        \texttt{0}  & \texttt{1}  & \texttt{0}  & \texttt{0}  & \texttt{1100} & \texttt{0001} & \texttt{1101} \\
        % OF, SF.
        \texttt{1}  & \texttt{1}  & \texttt{0}  & \texttt{0}  & \texttt{0111} & \texttt{0001} & \texttt{1000} \\
        % CF and SF, but no OF.
        \texttt{0}  & \texttt{1}  & \texttt{0}  & \texttt{1}  & \texttt{1100} & \texttt{1101} & \texttt{1001}
      \end{tabular}
    \end{center}

    NOTE: The adding circuits do not even think about whether the numbers are
    signed or unsigned, because the addition is performed the same in both
    cases.
    % Sub
  \item \texttt{Sub dst src} subtracts \texttt{src} from \texttt{dst} and writes
    the result to \texttt{dst}.
    % Cmp
  \item \texttt{Cmp a1 a2} compares \texttt{a1} to \texttt{a2} by subtracting
    the former from the latter and sets the flags according to the result:
    \begin{itemize}
    \item \texttt{CF} is set if an extra bit was needed to complete the
      computation.
    \item \texttt{ZF} is set if \texttt{a2 - a1} $=$ \texttt{0}.
    \item \texttt{SF} is set if \texttt{a2 - a1} $<$ \texttt{0}.
    \item \texttt{OF} is set if either\ldots
      \begin{itemize}
      \item \ldots\texttt{a1} is negative, \texttt{a2} is positive, and
        \texttt{a2 - a1} $<$ \texttt{0}.
      \item \ldots\texttt{a1} is positive, \texttt{a2} is negative, and
        \texttt{a2 - a1} $>$ \texttt{0}.
      \end{itemize}
    \end{itemize}
    % Jmp
  \item \texttt{Jmp dst} jumps to the address at \texttt{dst}.
    % Je
  \item \texttt{Je dst} jumps to the address at \texttt{dst} if \texttt{ZF} is
    set.
    % Jne
  \item \texttt{Jne dst} jumps to the address at \texttt{dst} if \texttt{ZF} is
    \emph{not} set.
    % Jl
  \item \texttt{Jl dst} jumps to the address at \texttt{dst} if \texttt{SF} and
    \texttt{OF} have different values.
    % Jg
  \item \texttt{Jg dst} jumps to the address at \texttt{dst} if \texttt{SF} and
    \texttt{OF} are set to the same value and \texttt{ZF} is unset.
    % And
  \item \texttt{And dst src} computes the bitwise AND (\texttt{\&{}}) of the
    operands and stores the result in \texttt{dst}.
    % Or
  \item \texttt{Or dst src} computes the bitwise OR (\texttt{|}) of the operands
    and stores the result in \texttt{dst}.
    % Xor
  \item \texttt{Xor dst src} computes the bitwise XOR (\texttt{\^{}}) of the
    operands and stores the result in \texttt{dst}.
    % Sal
  \item \texttt{Sal dst i} arithmetically shifts the bits in \texttt{dst} to the
    left by \texttt{i} bits and stores the result in \texttt{dst}. The new bits
    from the right are \texttt{0}s, and the \texttt{CF} flag is updated to the
    value of the most-significant bit during each shift.

    NOTE: When \texttt{i} is \texttt{1}, the \texttt{OF} flag is set if the
    most-significant bit of the result is different from the value of the
    \texttt{CF} flag, and cleared if they are the same.
    % Sar
  \item \texttt{Sar dst src} arithmetically shifts the bits in \texttt{dst} to
    the right by \texttt{i} bits and stores the result in \texttt{dst}. The new
    bits from the left are duplicated from the original most-significant bit,
    and the \texttt{CF} flag is updated to the value of the least-significant
    bit during each shift.

    NOTE: In contrast to \texttt{Sal}, the \texttt{OF} flag is always cleared
    for \texttt{Sar}.
    % Push
  \item \texttt{Push src} decrements the stack pointer and stores the
    \texttt{src} operands on the top of the stack.
    % Pop
  \item \texttt{Pop dst} loads the value from the top of the stack into the
    \texttt{dst} operand and increments the stack pointer.
    % Lea
  \item \texttt{Lea dst l} loads the address of the label \texttt{l} and stores
    it in \texttt{dst}.
  \end{itemize}
}

\end{document}